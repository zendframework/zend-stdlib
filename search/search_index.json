{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-stdlib Zend\\Stdlib is a set of components that implements general purpose utility class for different scopes like: array utilities functions; general messaging systems; string wrappers; etc. File issues at https://github.com/zendframework/zend-stdlib/issues Documentation is at https://docs.zendframework.com/zend-stdlib/ Benchmarks We provide scripts for benchmarking zend-stdlib using the PHPBench framework; these can be found in the benchmark/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"zend-stdlib"},{"location":"#zend-stdlib","text":"Zend\\Stdlib is a set of components that implements general purpose utility class for different scopes like: array utilities functions; general messaging systems; string wrappers; etc. File issues at https://github.com/zendframework/zend-stdlib/issues Documentation is at https://docs.zendframework.com/zend-stdlib/","title":"zend-stdlib"},{"location":"#benchmarks","text":"We provide scripts for benchmarking zend-stdlib using the PHPBench framework; these can be found in the benchmark/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"Benchmarks"},{"location":"console-helper/","text":"Console Helper Writing one-off scripts or vendor binaries for a package is often problematic: You need to parse arguments manually. You need to send output to the console in a meaningful fashion: Using STDOUT for meaningful, expected output Using STDERR for error messages Ensuring any line breaks are converted to PHP_EOL Optionally, using console colors to provide context, which means: Detecting whether or not the console supports colors in the first place Providing appropriate escape sequences to produce color Zend\\Stdlib\\ConsoleHelper helps to address the second major bullet point and all beneath it in a minimal fashion. Usage Typical usage is to instantiate a ConsoleHelper , and call one of its methods: use Zend\\Stdlib\\ConsoleHelper; $helper = new ConsoleHelper(); $helper->writeLine('This is output'); You can optionally pass a PHP stream resource to the constructor, which will be used to determine whether or not color support is available: $helper = new ConsoleHelper($stream); By default, it assumes STDOUT , and tests against that. Available methods ConsoleHelper provides the following methods. colorize colorize(string $string) : string colorize() accepts a formatted string, and will then apply ANSI color sequences to them, if color support is detected. The following sequences are currently supported: <info>...</info> will apply a green color sequence around the provided text. <error>...</error> will apply a red color sequence around the provided text. You may mix multiple sequences within the same stream. write write(string $string, bool $colorize = true, resource $stream = STDOUT) : void Emits the provided $string to the provided $stream (which defaults to STDOUT if not provided). Any EOL sequences are convered to PHP_EOL . If $colorize is true , the string is first passed to colorize() as well. writeline writeLine(string $string, bool $colorize = true, resource $stream = STDOUT) : void Same as write() , except it also appends a PHP_EOL sequence to the $string . writeErrorMessage writeErrorMessage(string $message) Wraps $message in an <error></error> sequence, and passes it to writeLine() , using STDERR as the $stream . Example Below is an example class that accepts an argument list, and determines how and what to emit. namespace Foo; use Zend\\Stdlib\\ConsoleHelper; class HelloWorld { private $helper; public function __construct(ConsoleHelper $helper = null) { $this->helper = $helper ?: new ConsoleHelper(); } public function __invoke(array $args) { if (! count($args)) { $this->helper->writeErrorMessage('Missing arguments!'); return; } if (count($args) > 1) { $this->helper->writeErrorMessage('Too many arguments!'); return; } $target = array_shift($args); $this->helper->writeLine(sprintf( '<info>Hello</info> %s', $target )); } } When to upgrade ConsoleHelper is deliberately simple, and assumes that your primary need for console tooling is for output considerations. If you need to parse complex argument strings, we recommend using zend-console / zf-console or symfony/console , as these packages provide those capabilities, as well as far more colorization and console feature detection facilities.","title":"Console Helper"},{"location":"console-helper/#console-helper","text":"Writing one-off scripts or vendor binaries for a package is often problematic: You need to parse arguments manually. You need to send output to the console in a meaningful fashion: Using STDOUT for meaningful, expected output Using STDERR for error messages Ensuring any line breaks are converted to PHP_EOL Optionally, using console colors to provide context, which means: Detecting whether or not the console supports colors in the first place Providing appropriate escape sequences to produce color Zend\\Stdlib\\ConsoleHelper helps to address the second major bullet point and all beneath it in a minimal fashion.","title":"Console Helper"},{"location":"console-helper/#usage","text":"Typical usage is to instantiate a ConsoleHelper , and call one of its methods: use Zend\\Stdlib\\ConsoleHelper; $helper = new ConsoleHelper(); $helper->writeLine('This is output'); You can optionally pass a PHP stream resource to the constructor, which will be used to determine whether or not color support is available: $helper = new ConsoleHelper($stream); By default, it assumes STDOUT , and tests against that.","title":"Usage"},{"location":"console-helper/#available-methods","text":"ConsoleHelper provides the following methods.","title":"Available methods"},{"location":"console-helper/#colorize","text":"colorize(string $string) : string colorize() accepts a formatted string, and will then apply ANSI color sequences to them, if color support is detected. The following sequences are currently supported: <info>...</info> will apply a green color sequence around the provided text. <error>...</error> will apply a red color sequence around the provided text. You may mix multiple sequences within the same stream.","title":"colorize"},{"location":"console-helper/#write","text":"write(string $string, bool $colorize = true, resource $stream = STDOUT) : void Emits the provided $string to the provided $stream (which defaults to STDOUT if not provided). Any EOL sequences are convered to PHP_EOL . If $colorize is true , the string is first passed to colorize() as well.","title":"write"},{"location":"console-helper/#writeline","text":"writeLine(string $string, bool $colorize = true, resource $stream = STDOUT) : void Same as write() , except it also appends a PHP_EOL sequence to the $string .","title":"writeline"},{"location":"console-helper/#writeerrormessage","text":"writeErrorMessage(string $message) Wraps $message in an <error></error> sequence, and passes it to writeLine() , using STDERR as the $stream .","title":"writeErrorMessage"},{"location":"console-helper/#example","text":"Below is an example class that accepts an argument list, and determines how and what to emit. namespace Foo; use Zend\\Stdlib\\ConsoleHelper; class HelloWorld { private $helper; public function __construct(ConsoleHelper $helper = null) { $this->helper = $helper ?: new ConsoleHelper(); } public function __invoke(array $args) { if (! count($args)) { $this->helper->writeErrorMessage('Missing arguments!'); return; } if (count($args) > 1) { $this->helper->writeErrorMessage('Too many arguments!'); return; } $target = array_shift($args); $this->helper->writeLine(sprintf( '<info>Hello</info> %s', $target )); } }","title":"Example"},{"location":"console-helper/#when-to-upgrade","text":"ConsoleHelper is deliberately simple, and assumes that your primary need for console tooling is for output considerations. If you need to parse complex argument strings, we recommend using zend-console / zf-console or symfony/console , as these packages provide those capabilities, as well as far more colorization and console feature detection facilities.","title":"When to upgrade"},{"location":"migration/","text":"Migration Guide From v2 to v3 The changes made going from v2 to v3 were: Removal of the Hydrator subcomponent. Removal of the CallbackHandler class. Removal of Zend\\Stdlib\\Guard\\GuardUtils . Hydrators The biggest single change from version 2 to version 3 is that the hydrator subcomponent, which was deprecated in v2.7.0, is now removed. This means that if you were using zend-stdlib principally for the hydrators, you need to convert your code to use zend-hydrator . This will also mean a multi-step migration. zend-stdlib v3 pre-dates zend-hydrator v2.1, which will be the first version that supports zend-stdlib v3 and zend-servicemanager v3. If you are using Composer, the migration should be seamless: Remove your zend-stdlib dependency: $ composer remove zendframework/zend-stdlib Update to use zend-hydrator: $ composer require zendframework/zend-hydrator When zend-hydrator updates to newer versions of zend-stdlib and zend-servicemanager, you will either automatically get those versions, or you can tell composer to use those specific versions: $ composer require \"zendframework/zend-stdlib:^3.0\" CallbackHandler Zend\\Stdlib\\CallbackHandler primarily existed for legacy purposes; it was created before the callable typehint existed, so that we could typehint PHP callables. It also provided some minimal features around lazy-loading callables from instantiable classes, but these features were rarely used, and better approaches already exist for handling such functinality in zend-servicemanager and zend-expressive. As such, the class was marked deprecated in v2.7.0, and removed for v3.0.0. GuardUtils Version 3 removes Zend\\Stdlib\\Guard\\GuardUtils . This abstract class existed to provide the functionality of the various traits also present in that subcomponent, for consumers on versions of PHP earlier than 5.4. Since the minimum required version is now PHP 5.5, the class is unnecessary. If you were using it previously, compose the related traits instead.","title":"Migration"},{"location":"migration/#migration-guide","text":"","title":"Migration Guide"},{"location":"migration/#from-v2-to-v3","text":"The changes made going from v2 to v3 were: Removal of the Hydrator subcomponent. Removal of the CallbackHandler class. Removal of Zend\\Stdlib\\Guard\\GuardUtils .","title":"From v2 to v3"},{"location":"migration/#hydrators","text":"The biggest single change from version 2 to version 3 is that the hydrator subcomponent, which was deprecated in v2.7.0, is now removed. This means that if you were using zend-stdlib principally for the hydrators, you need to convert your code to use zend-hydrator . This will also mean a multi-step migration. zend-stdlib v3 pre-dates zend-hydrator v2.1, which will be the first version that supports zend-stdlib v3 and zend-servicemanager v3. If you are using Composer, the migration should be seamless: Remove your zend-stdlib dependency: $ composer remove zendframework/zend-stdlib Update to use zend-hydrator: $ composer require zendframework/zend-hydrator When zend-hydrator updates to newer versions of zend-stdlib and zend-servicemanager, you will either automatically get those versions, or you can tell composer to use those specific versions: $ composer require \"zendframework/zend-stdlib:^3.0\"","title":"Hydrators"},{"location":"migration/#callbackhandler","text":"Zend\\Stdlib\\CallbackHandler primarily existed for legacy purposes; it was created before the callable typehint existed, so that we could typehint PHP callables. It also provided some minimal features around lazy-loading callables from instantiable classes, but these features were rarely used, and better approaches already exist for handling such functinality in zend-servicemanager and zend-expressive. As such, the class was marked deprecated in v2.7.0, and removed for v3.0.0.","title":"CallbackHandler"},{"location":"migration/#guardutils","text":"Version 3 removes Zend\\Stdlib\\Guard\\GuardUtils . This abstract class existed to provide the functionality of the various traits also present in that subcomponent, for consumers on versions of PHP earlier than 5.4. Since the minimum required version is now PHP 5.5, the class is unnecessary. If you were using it previously, compose the related traits instead.","title":"GuardUtils"}]}